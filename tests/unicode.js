import test from "ava";
import { Ucs2ToBytesTransform, BytesToUcs2Transform, Utf8ToBytesTransform, Utf16ToBytesTransform, BytesToUtf16Transform } from "transforms/unicode";
import { TransformError } from "transforms/transforms";

// UCS-2

test("Decodes simple UCS-2 (BE)", t => {
	const tf = new Ucs2ToBytesTransform();

	t.deepEqual(tf.transform("它不是一个填字游戏"), [0x5b, 0x83, 0x4e, 0x0d, 0x66, 0x2f, 0x4e, 0x00, 0x4e, 0x2a, 0x58, 0x6b, 0x5b, 0x57, 0x6e, 0x38, 0x62, 0x0f]);
});

test("Decodes UCS-2 (LE)", t => {
	const tf = new Ucs2ToBytesTransform();

	t.deepEqual(tf.transform("它不是一个填字游戏", { littleEndian: true }), [0x83, 0x5b, 0x0d, 0x4e, 0x2f, 0x66, 0x00, 0x4e, 0x2a, 0x4e, 0x6b, 0x58, 0x57, 0x5b, 0x38, 0x6e, 0x0f, 0x62]);
});

// TODO: Test SMP (shouldn't decode in UCS-2)

test("UCS-2 Decoder handles empty string gracefully", t => {
	const tf = new Ucs2ToBytesTransform();

	t.deepEqual(tf.transform(""), []);
});

test("Encodes simple UCS-2 (BE)", t => {
	const tf = new BytesToUcs2Transform();

	t.is(tf.transform([0x5b, 0x83, 0x4e, 0x0d, 0x66, 0x2f, 0x4e, 0x00, 0x4e, 0x2a, 0x58, 0x6b, 0x5b, 0x57, 0x6e, 0x38, 0x62, 0x0f]), "它不是一个填字游戏");
});

test("Encodes UCS-2 (LE)", t => {
	const tf = new BytesToUcs2Transform();

	t.is(tf.transform([0x83, 0x5b, 0x0d, 0x4e, 0x2f, 0x66, 0x00, 0x4e, 0x2a, 0x4e, 0x6b, 0x58, 0x57, 0x5b, 0x38, 0x6e, 0x0f, 0x62], { littleEndian: true }), "它不是一个填字游戏");
});

test("UCS-2 Encoder handles empty array gracefully", t => {
	const tf = new BytesToUcs2Transform();

	t.deepEqual(tf.transform([]), "");
});

// UTF-8
test("Decodes UTF-8 Latin", t => {
	const tf = new Utf8ToBytesTransform();

	t.deepEqual(tf.transform("æøåÆØÅ§¤ñ"), [0xc3, 0xa6, 0xc3, 0xb8, 0xc3, 0xa5, 0xc3, 0x86, 0xc3, 0x98, 0xc3, 0x85, 0xc2, 0xa7, 0xc2, 0xa4, 0xc3, 0xb1]);
});

test("Decodes UTF-8 BMP", t => {
	const tf = new Utf8ToBytesTransform();

	t.deepEqual(tf.transform("Ξεσκεπάζω"), [0xce, 0x9e, 0xce, 0xb5, 0xcf, 0x83, 0xce, 0xba, 0xce, 0xb5, 0xcf, 0x80, 0xce, 0xac, 0xce, 0xb6, 0xcf, 0x89]);
});

test("Decodes UTF-8 SMP", t => {
	const tf = new Utf8ToBytesTransform();

	t.deepEqual(tf.transform("𠜎𠾴𢵌𨳒"), [0xf0, 0xa0, 0x9c, 0x8e, 0xf0, 0xa0, 0xbe, 0xb4, 0xf0, 0xa2, 0xb5, 0x8c, 0xf0, 0xa8, 0xb3, 0x92]);
});

test("UTF-8 Decoder handles empty string gracefully", t => {
	const tf = new Utf8ToBytesTransform();

	t.deepEqual(tf.transform(""), []);
});


// UTF-16

test("Decodes UTF-16 BMP (BE)", t => {
	const tf = new Utf16ToBytesTransform();

	t.deepEqual(tf.transform("Ξεσκεπάζω"), [0x03, 0x9e, 0x03, 0xb5, 0x03, 0xc3, 0x03, 0xba, 0x03, 0xb5, 0x03, 0xc0, 0x03, 0xac, 0x03, 0xb6, 0x03, 0xc9]);
});

test("Decodes UTF-16 SMP (BE)", t => {
	const tf = new Utf16ToBytesTransform();

	t.deepEqual(tf.transform("𠜎𠾴𢵌𨳒"), [0xd8, 0x41, 0xdf, 0x0e, 0xd8, 0x43, 0xdf, 0xb4, 0xd8, 0x4b, 0xdd, 0x4c, 0xd8, 0x63, 0xdc, 0xd2]);
});

test("Decodes UTF-16 BMP (LE)", t => {
	const tf = new Utf16ToBytesTransform();

	t.deepEqual(tf.transform("Ξεσκεπάζω", { littleEndian: true }), [0x9e, 0x03, 0xb5, 0x03, 0xc3, 0x03, 0xba, 0x03, 0xb5, 0x03, 0xc0, 0x03, 0xac, 0x03, 0xb6, 0x03, 0xc9, 0x03]);
});

test("Decodes UTF-16 SMP (LE)", t => {
	const tf = new Utf16ToBytesTransform();

	t.deepEqual(tf.transform("𠜎𠾴𢵌𨳒", { littleEndian: true }), [0x41, 0xd8, 0x0e, 0xdf, 0x43, 0xd8, 0xb4, 0xdf, 0x4b, 0xd8, 0x4c, 0xdd, 0x63, 0xd8, 0xd2, 0xdc]);
});

test("Encodes UTF-16 BMP (BE)", t => {
	const tf = new BytesToUtf16Transform();

	t.deepEqual(tf.transform([0x03, 0x9e, 0x03, 0xb5, 0x03, 0xc3, 0x03, 0xba, 0x03, 0xb5, 0x03, 0xc0, 0x03, 0xac, 0x03, 0xb6, 0x03, 0xc9]), "Ξεσκεπάζω");
});

test("Encodes UTF-16 SMP (BE)", t => {
	const tf = new BytesToUtf16Transform();

	t.deepEqual(tf.transform([0xd8, 0x41, 0xdf, 0x0e, 0xd8, 0x43, 0xdf, 0xb4, 0xd8, 0x4b, 0xdd, 0x4c, 0xd8, 0x63, 0xdc, 0xd2]), "𠜎𠾴𢵌𨳒");
});

test("Encodes UTF-16 BMP (LE)", t => {
	const tf = new BytesToUtf16Transform();

	t.deepEqual(tf.transform([0x9e, 0x03, 0xb5, 0x03, 0xc3, 0x03, 0xba, 0x03, 0xb5, 0x03, 0xc0, 0x03, 0xac, 0x03, 0xb6, 0x03, 0xc9, 0x03], { littleEndian: true }), "Ξεσκεπάζω");
});

test("Encodes UTF-16 SMP (LE)", t => {
	const tf = new BytesToUtf16Transform();

	t.deepEqual(tf.transform([0x41, 0xd8, 0x0e, 0xdf, 0x43, 0xd8, 0xb4, 0xdf, 0x4b, 0xd8, 0x4c, 0xdd, 0x63, 0xd8, 0xd2, 0xdc], { littleEndian: true }), "𠜎𠾴𢵌𨳒");
});
