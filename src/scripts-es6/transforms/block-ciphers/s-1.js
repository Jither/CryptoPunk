import { BlockCipherTransform } from "./block-cipher";
import { xorBytes } from "../../cryptopunk.bitarith";

const F0 = [
	0x7, 0x2, 0x9, 0xc, 0x8, 0xe, 0x1, 0x6, 0xd, 0x2, 0x0, 0x4, 0xf, 0x7, 0x3, 0xf, 0x8, 0xf, 0xa, 0x5, 0xb, 0x0, 0xf, 0x2, 0x5, 0xd, 0xf, 0xf, 0x9, 0x9, 0x6, 0xc, 
	0x7, 0xf, 0xa, 0xe, 0xa, 0x6, 0x4, 0x4, 0xc, 0x4, 0xf, 0xb, 0x3, 0xc, 0xc, 0x6, 0x6, 0x0, 0x2, 0x8, 0xa, 0xa, 0x3, 0xd, 0xb, 0xc, 0xf, 0x5, 0x5, 0x0, 0x7, 0xc, 
	0xe, 0x9, 0x3, 0x9, 0x8, 0xc, 0xa, 0xc, 0xf, 0x5, 0x7, 0x5, 0x7, 0xe, 0x3, 0x2, 0x9, 0xc, 0x4, 0x0, 0x8, 0xe, 0x2, 0x3, 0x2, 0xe, 0xb, 0x4, 0x8, 0x1, 0x6, 0xb, 
	0xe, 0x8, 0xf, 0xc, 0x0, 0x2, 0x0, 0x1, 0x1, 0xb, 0xe, 0x0, 0x2, 0xb, 0xf, 0xb, 0xe, 0xe, 0x2, 0x5, 0x2, 0x0, 0xe, 0x1, 0x8, 0xb, 0x9, 0x6, 0x1, 0x5, 0x7, 0x7, 
	0xe, 0xc, 0xa, 0x9, 0x9, 0xe, 0x7, 0xc, 0x9, 0xd, 0xa, 0x0, 0x8, 0x0, 0x7, 0xa, 0xd, 0xb, 0x0, 0xa, 0x4, 0xf, 0x5, 0x0, 0xd, 0x2, 0xe, 0x3, 0x3, 0xb, 0x6, 0x9, 
	0xc, 0x3, 0xf, 0xc, 0x0, 0xb, 0x6, 0xf, 0x8, 0xd, 0x1, 0xa, 0x5, 0x8, 0x6, 0x7, 0x6, 0x3, 0xf, 0x6, 0xd, 0xd, 0x1, 0xb, 0x4, 0xa, 0x3, 0x0, 0x6, 0x9, 0x9, 0xd, 
	0xa, 0xf, 0xe, 0x1, 0xd, 0xe, 0xf, 0x4, 0xd, 0x6, 0x7, 0x4, 0x0, 0xf, 0xe, 0xf, 0x8, 0x2, 0x4, 0xa, 0x1, 0x2, 0x9, 0x7, 0x8, 0x8, 0x2, 0x2, 0x7, 0x8, 0x8, 0xb, 
	0x3, 0xe, 0xf, 0x9, 0x6, 0x9, 0x0, 0xf, 0xc, 0x6, 0x4, 0x2, 0x3, 0x0, 0x9, 0xb, 0xc, 0x5, 0x3, 0xe, 0xb, 0xf, 0x4, 0x5, 0xf, 0x9, 0x3, 0x6, 0x8, 0xb, 0xc, 0x6
];

const F1 = [
	0xf, 0x6, 0xe, 0xd, 0xa, 0x7, 0x7, 0x3, 0x3, 0x1, 0xf, 0x0, 0xb, 0x7, 0x2, 0x8, 0x1, 0xc, 0xa, 0x1, 0x7, 0x3, 0x1, 0xe, 0xc, 0x9, 0x0, 0x1, 0x6, 0x2, 0x9, 0xb, 
	0xc, 0x9, 0x7, 0xa, 0x3, 0x3, 0x8, 0x0, 0x0, 0xa, 0x4, 0x0, 0x2, 0xf, 0xd, 0xb, 0x2, 0xf, 0x5, 0x4, 0x3, 0xb, 0xf, 0x3, 0x9, 0xa, 0x1, 0x9, 0x7, 0x9, 0x9, 0x8, 
	0x1, 0x5, 0x2, 0x3, 0x8, 0xf, 0x7, 0xa, 0xd, 0x9, 0x8, 0xf, 0x3, 0xe, 0x3, 0xd, 0x9, 0xb, 0x5, 0x7, 0xf, 0xa, 0xa, 0x7, 0xf, 0x5, 0x7, 0x0, 0x4, 0x4, 0x4, 0x6, 
	0x9, 0x4, 0x7, 0x8, 0x8, 0xd, 0xf, 0x0, 0xa, 0x2, 0x1, 0xe, 0x0, 0x5, 0x3, 0x9, 0x5, 0xc, 0x9, 0x0, 0x9, 0x0, 0xb, 0x8, 0xe, 0xc, 0x4, 0x3, 0xd, 0xe, 0x2, 0x3, 
	0xa, 0x6, 0xf, 0x0, 0x9, 0x9, 0x2, 0xf, 0xb, 0x4, 0x7, 0x2, 0x2, 0xc, 0x4, 0x7, 0xc, 0x1, 0x0, 0x3, 0x1, 0x8, 0x1, 0x7, 0xa, 0x0, 0xd, 0x4, 0x0, 0xf, 0x4, 0x0, 
	0xf, 0xc, 0x4, 0x7, 0xb, 0x9, 0xa, 0xf, 0xf, 0x3, 0x7, 0x0, 0x4, 0x7, 0x7, 0x3, 0x5, 0x6, 0xf, 0x3, 0xf, 0x2, 0x4, 0xf, 0x0, 0xc, 0xf, 0x4, 0x5, 0xe, 0xd, 0x4, 
	0xa, 0xb, 0x0, 0x4, 0xf, 0x7, 0xb, 0x4, 0x8, 0x5, 0x7, 0x4, 0xb, 0x5, 0xe, 0x8, 0xd, 0x0, 0x4, 0x4, 0xf, 0x8, 0x5, 0xd, 0x9, 0x1, 0xa, 0xb, 0xd, 0x3, 0x8, 0x5, 
	0x7, 0x6, 0x0, 0x2, 0x9, 0x6, 0x0, 0xf, 0x1, 0x8, 0x3, 0x6, 0x5, 0x8, 0x8, 0xa, 0xc, 0x2, 0x2, 0x2, 0x8, 0x4, 0xb, 0x7, 0xe, 0xd, 0x5, 0xf, 0x5, 0x3, 0x8, 0x8
];

const F2 = [
	0xb, 0x9, 0xf, 0x7, 0x1, 0xa, 0x0, 0x9, 0x6, 0x8, 0xa, 0xc, 0x0, 0xa, 0x1, 0xa, 0x9, 0xc, 0x5, 0x5, 0x7, 0x4, 0xb, 0xd, 0x4, 0x0, 0x1, 0x8, 0xf, 0x2, 0xd, 0xa, 
	0x6, 0x0, 0x7, 0xf, 0xc, 0xb, 0x9, 0x3, 0x7, 0xb, 0x6, 0x5, 0x9, 0x8, 0x0, 0x2, 0x7, 0x9, 0xe, 0x1, 0xa, 0xc, 0xa, 0x6, 0x9, 0xe, 0xd, 0x6, 0x7, 0x5, 0xc, 0x7, 
	0x1, 0x6, 0xa, 0x6, 0x5, 0x4, 0x3, 0x9, 0x4, 0xc, 0xb, 0x0, 0x8, 0xe, 0x3, 0x6, 0x0, 0xf, 0x2, 0x8, 0x8, 0xa, 0xa, 0xf, 0x7, 0x3, 0xa, 0xa, 0xb, 0xc, 0xb, 0x3, 
	0x9, 0xa, 0x6, 0x2, 0x2, 0x2, 0x9, 0x4, 0x6, 0x8, 0x5, 0x1, 0xe, 0x7, 0xf, 0x0, 0xb, 0xa, 0xe, 0x7, 0xe, 0x1, 0x4, 0xd, 0x7, 0xc, 0x0, 0x4, 0x6, 0xe, 0x9, 0xc, 
	0x6, 0x9, 0xa, 0x2, 0xa, 0xe, 0xb, 0x0, 0x0, 0x3, 0x3, 0xd, 0x7, 0xa, 0x0, 0xa, 0xf, 0x9, 0x5, 0x5, 0x8, 0x4, 0x4, 0x5, 0xc, 0xa, 0x9, 0xd, 0xd, 0xb, 0xf, 0xc, 
	0x9, 0x7, 0xb, 0x1, 0x0, 0xd, 0x9, 0x5, 0xd, 0xe, 0xa, 0xf, 0x1, 0xd, 0x7, 0xa, 0x8, 0xf, 0x7, 0x4, 0x9, 0xb, 0x1, 0x8, 0x6, 0x3, 0x8, 0x2, 0x5, 0x8, 0x9, 0x2, 
	0x4, 0xf, 0xa, 0x6, 0x5, 0x5, 0xd, 0xa, 0x0, 0x3, 0x4, 0xd, 0xe, 0xd, 0xd, 0x9, 0x3, 0x5, 0xb, 0xe, 0x2, 0xf, 0xb, 0x0, 0x3, 0xa, 0x2, 0x7, 0x3, 0x8, 0x9, 0x1, 
	0x6, 0x2, 0xc, 0x1, 0xa, 0x8, 0x2, 0xa, 0xb, 0xf, 0xb, 0xc, 0x5, 0x2, 0x2, 0xb, 0x9, 0xb, 0x2, 0x5, 0xc, 0xf, 0x6, 0xd, 0x1, 0x9, 0xa, 0x0, 0xb, 0x5, 0x3, 0xd
];

const F3 = [
	0xb, 0x7, 0x4, 0x1, 0x3, 0xf, 0x7, 0x5, 0xc, 0x2, 0x5, 0xe, 0xb, 0x4, 0xb, 0x1, 0xd, 0xd, 0xc, 0xd, 0x1, 0x8, 0x4, 0x2, 0x7, 0xd, 0xe, 0xe, 0x1, 0x3, 0x9, 0x9, 
	0x8, 0xf, 0x6, 0x4, 0xb, 0x8, 0xc, 0xb, 0x3, 0x8, 0xd, 0x7, 0x7, 0x0, 0x5, 0x1, 0x3, 0xb, 0xd, 0x4, 0xf, 0xd, 0x3, 0xf, 0xb, 0x3, 0xb, 0x9, 0x0, 0x8, 0x1, 0x7, 
	0x3, 0x4, 0x4, 0x3, 0x3, 0x8, 0xe, 0x0, 0x1, 0x9, 0xd, 0x2, 0xb, 0x3, 0x7, 0x8, 0x8, 0x7, 0xc, 0xd, 0xb, 0x5, 0x0, 0xa, 0xa, 0xe, 0x7, 0x2, 0xf, 0x6, 0xf, 0xd, 
	0xb, 0x2, 0x3, 0xb, 0x1, 0x2, 0xf, 0x6, 0x4, 0x7, 0x4, 0xf, 0x3, 0x3, 0x2, 0x0, 0x5, 0x1, 0x0, 0xe, 0xc, 0x5, 0x2, 0x4, 0x7, 0xc, 0x7, 0xa, 0x5, 0xf, 0x9, 0x1, 
	0x6, 0x0, 0xd, 0xc, 0xf, 0x1, 0x0, 0x4, 0x0, 0x0, 0x9, 0x4, 0xb, 0xa, 0x3, 0xd, 0x1, 0x5, 0x4, 0x2, 0x9, 0x7, 0x0, 0x9, 0xd, 0x9, 0x0, 0x5, 0x7, 0xe, 0xf, 0x2, 
	0x5, 0xb, 0x6, 0x4, 0x6, 0x1, 0xb, 0x4, 0x6, 0xd, 0x8, 0xa, 0x3, 0x8, 0xf, 0xb, 0x9, 0x8, 0x7, 0x0, 0xc, 0x3, 0x5, 0x0, 0xb, 0xe, 0xb, 0xc, 0x1, 0x2, 0xe, 0x6, 
	0xa, 0xe, 0xc, 0x3, 0x4, 0x6, 0x0, 0xf, 0x0, 0xc, 0x5, 0xe, 0x1, 0x1, 0x4, 0x3, 0x1, 0x8, 0x0, 0xb, 0x8, 0x3, 0xd, 0x3, 0x7, 0xf, 0xc, 0xa, 0x6, 0x1, 0x1, 0x3, 
	0x0, 0x6, 0xa, 0x5, 0x5, 0x6, 0x7, 0x8, 0xf, 0xe, 0x1, 0x5, 0x0, 0xe, 0x0, 0x0, 0xc, 0xf, 0x8, 0x0, 0x6, 0xa, 0x9, 0xe, 0xf, 0xf, 0x3, 0x3, 0xc, 0x0, 0xd, 0xf	
];

const F = [F0, F1, F2, F3];

const G0 = [ 0, 0, 1, 1, 0, 1, 1, 0, 0, 1 ];
const G1 = [
	0, 1, 1, 0, 1, 0, 0, 1,
	0, 1, 1, 0, 1, 0, 0, 1,
	1, 0, 0, 1, 0, 1, 1, 0,
	1, 0, 0, 1, 0, 1, 1, 0
];

const JSHIFT = [ 5, 8, 3, 1, 4, 0 ];

const UFV_CLEAR = [ 0x81, 0x03, 0x05, 0x07, 0x02, 0x04, 0x06, 0x83 ];
const UFV_CIPHER = [ 0x01, 0xfe, 0xfd, 0xfc, 0x80, 0x81, 0x82, 0x08 ];

class S1Transform extends BlockCipherTransform
{
	constructor(decrypt)
	{
		super(decrypt);
		this.addOption("doubleR", "Double-R", true);
	}

	transform(bytes, keyBytes)
	{
		this.checkBytesSize("Key", keyBytes, 80);
		const keys = this.generateKeys(keyBytes);
		return this.transformBlocks(bytes, 64, keys);
	}

	generateKeys(keyBytes)
	{
		const keys = new Array(5);
		// TODO: The original key schedule actually repeats every 5 rounds, so no need for 32 round keys
		for (let r = 0; r < 5; r++)
		{
			const key = keys[r] = new Uint8Array(6);
			for (let j = 0; j < 6; j++)
			{
				const i = r * 6 + j;
				key[j] =
					(F0[keyBytes[(i + JSHIFT[ j         ]) % 10]]     ) ^
					(F1[keyBytes[(i + JSHIFT[(j + 1) % 6]) % 10]]     ) ^
					(F2[keyBytes[(i + JSHIFT[(j + 2) % 6]) % 10]] << 4) ^
					(F3[keyBytes[(i + JSHIFT[(j + 3) % 6]) % 10]] << 4);
			}
		}
		return keys;
	}
}

class S1EncryptTransform extends S1Transform
{
	constructor()
	{
		super(false);
	}

	transformBlock(block, dest, destOffset, keys)
	{
		const state = Uint8Array.from(block);

		xorBytes(state, UFV_CLEAR);
		
		for (let i = 0; i < 32; i++)
		{
			// Doesn't make sense to use 2 * i for keys, which begs the question:
			// Is r even supposed to be 2 * i? So there's an option for that.
			const r = this.options.doubleR ? i * 2 : i;
			const key = keys[i % 5];
			const g0index = key[0] ^ state[(r + 4) % 8];
			const g1index = key[1] ^ state[(r + 5) % 8];
			const startF = G0[g0index % G0.length] + G1[g1index % G1.length] * 2;
			
			for (let k = 0; k < 4; k++)
			{
				const index = k < 2 ? (r + 6) % 8 : (r + 7) % 8;
				const fIndex = key[k + 2] ^ state[(r + (k + 2) % 4) % 8];
				let x = F[(startF + k) % 4][fIndex];
				if (k & 1)
				{
					x <<= 4;
				}
				state[index] ^= x;
			}
		}

		xorBytes(state, UFV_CIPHER);
		
		dest.set(state, destOffset);
	}
}

class S1DecryptTransform extends S1Transform
{
	constructor()
	{
		super(true);
	}

	transformBlock(block, dest, destOffset, keys)
	{
		const state = Uint8Array.from(block);

		xorBytes(state, UFV_CIPHER);
		
		for (let i = 31; i >= 0; i--)
		{
			// Doesn't make sense to use 2 * i for keys, which begs the question:
			// Is r even supposed to be 2 * i? So there's an option for that.
			const r = this.options.doubleR ? i * 2 : i;
			const key = keys[i % 5];
			const g0index = key[0] ^ state[(r + 4) % 8];
			const g1index = key[1] ^ state[(r + 5) % 8];

			const startF = G0[g0index % G0.length] + G1[g1index % G1.length] * 2;

			for (let k = 0; k < 4; k++)
			{
				const index = k < 2 ? (r + 6) % 8 : (r + 7) % 8;
				const fIndex = key[k + 2] ^ state[(r + (k + 2) % 4) % 8];
				let x = F[(startF + k) % 4][fIndex];
				if (k & 1)
				{
					x <<= 4;
				}
				state[index] ^= x;
			}
		}

		xorBytes(state, UFV_CLEAR);
				
		dest.set(state, destOffset);
	}
}

export {
	S1EncryptTransform,
	S1DecryptTransform
};