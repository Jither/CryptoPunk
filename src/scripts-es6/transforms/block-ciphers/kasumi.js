import { BlockCipherTransform } from "./block-cipher";
import { bytesToInt32sBE, int32sToBytesBE, bytesToInt16sBE } from "../../cryptopunk.utils";
import { rol16 } from "../../cryptopunk.bitarith";

// KASUMI is heavily based on MISTY1.

// KASUMI vs. MISTY: Different S-boxes
const S_BOX_7 = [
	0x36, 0x32, 0x3e, 0x38, 0x16, 0x22, 0x5e, 0x60, 0x26, 0x06, 0x3f, 0x5d, 0x02, 0x12, 0x7b, 0x21, 
	0x37, 0x71, 0x27, 0x72, 0x15, 0x43, 0x41, 0x0c, 0x2f, 0x49, 0x2e, 0x1b, 0x19, 0x6f, 0x7c, 0x51, 
	0x35, 0x09, 0x79, 0x4f, 0x34, 0x3c, 0x3a, 0x30, 0x65, 0x7f, 0x28, 0x78, 0x68, 0x46, 0x47, 0x2b, 
	0x14, 0x7a, 0x48, 0x3d, 0x17, 0x6d, 0x0d, 0x64, 0x4d, 0x01, 0x10, 0x07, 0x52, 0x0a, 0x69, 0x62, 
	0x75, 0x74, 0x4c, 0x0b, 0x59, 0x6a, 0x00, 0x7d, 0x76, 0x63, 0x56, 0x45, 0x1e, 0x39, 0x7e, 0x57, 
	0x70, 0x33, 0x11, 0x05, 0x5f, 0x0e, 0x5a, 0x54, 0x5b, 0x08, 0x23, 0x67, 0x20, 0x61, 0x1c, 0x42, 
	0x66, 0x1f, 0x1a, 0x2d, 0x4b, 0x04, 0x55, 0x5c, 0x25, 0x4a, 0x50, 0x31, 0x44, 0x1d, 0x73, 0x2c, 
	0x40, 0x6b, 0x6c, 0x18, 0x6e, 0x53, 0x24, 0x4e, 0x2a, 0x13, 0x0f, 0x29, 0x58, 0x77, 0x3b, 0x03
];

const S_BOX_9 = [
	0x0a7, 0x0ef, 0x0a1, 0x17b, 0x187, 0x14e, 0x009, 0x152, 0x026, 0x0e2, 0x030, 0x166, 0x1c4, 0x181, 0x05a, 0x18d, 
	0x0b7, 0x0fd, 0x093, 0x14b, 0x19f, 0x154, 0x033, 0x16a, 0x132, 0x1f4, 0x106, 0x052, 0x0d8, 0x09f, 0x164, 0x0b1, 
	0x0af, 0x0f1, 0x1e9, 0x025, 0x0ce, 0x011, 0x000, 0x14d, 0x02c, 0x0fe, 0x17a, 0x03a, 0x08f, 0x0dc, 0x051, 0x190, 
	0x05f, 0x003, 0x13b, 0x0f5, 0x036, 0x0eb, 0x0da, 0x195, 0x1d8, 0x108, 0x0ac, 0x1ee, 0x173, 0x122, 0x18f, 0x04c, 
	0x0a5, 0x0c5, 0x18b, 0x079, 0x101, 0x1e0, 0x1a7, 0x0d4, 0x0f0, 0x01c, 0x1ce, 0x0b0, 0x196, 0x1fb, 0x120, 0x0df, 
	0x1f5, 0x197, 0x0f9, 0x109, 0x059, 0x0ba, 0x0dd, 0x1ac, 0x0a4, 0x04a, 0x1b8, 0x0c4, 0x1ca, 0x1a5, 0x15e, 0x0a3, 
	0x0e8, 0x09e, 0x086, 0x162, 0x00d, 0x0fa, 0x1eb, 0x08e, 0x0bf, 0x045, 0x0c1, 0x1a9, 0x098, 0x0e3, 0x16e, 0x087, 
	0x158, 0x12c, 0x114, 0x0f2, 0x1b5, 0x140, 0x071, 0x116, 0x00b, 0x0f3, 0x057, 0x13d, 0x024, 0x05d, 0x1f0, 0x01b, 
	0x1e7, 0x1be, 0x1e2, 0x029, 0x044, 0x09c, 0x1c9, 0x083, 0x146, 0x193, 0x153, 0x014, 0x027, 0x073, 0x1ba, 0x07c, 
	0x1db, 0x180, 0x1fc, 0x035, 0x070, 0x0aa, 0x1df, 0x097, 0x07e, 0x0a9, 0x049, 0x10c, 0x117, 0x141, 0x0a8, 0x16c, 
	0x16b, 0x124, 0x02e, 0x1f3, 0x189, 0x147, 0x144, 0x018, 0x1c8, 0x10b, 0x09d, 0x1cc, 0x1e8, 0x1aa, 0x135, 0x0e5, 
	0x1b7, 0x1fa, 0x0d0, 0x10f, 0x15d, 0x191, 0x1b2, 0x0ec, 0x010, 0x0d1, 0x167, 0x034, 0x038, 0x078, 0x0c7, 0x115, 
	0x1d1, 0x1a0, 0x0fc, 0x11f, 0x0f6, 0x006, 0x053, 0x131, 0x1a4, 0x159, 0x099, 0x1f6, 0x041, 0x03d, 0x0f4, 0x11a, 
	0x0ad, 0x0de, 0x1a2, 0x043, 0x182, 0x170, 0x105, 0x065, 0x1dc, 0x123, 0x0c3, 0x1ae, 0x031, 0x04f, 0x0a6, 0x14a, 
	0x118, 0x17f, 0x175, 0x080, 0x17e, 0x198, 0x09b, 0x1ef, 0x16f, 0x184, 0x112, 0x06b, 0x1cb, 0x1a1, 0x03e, 0x1c6, 
	0x084, 0x0e1, 0x0cb, 0x13c, 0x0ea, 0x00e, 0x12d, 0x05b, 0x1f7, 0x11e, 0x1a8, 0x0d3, 0x15b, 0x133, 0x08c, 0x176, 
	0x023, 0x067, 0x07d, 0x1ab, 0x013, 0x0d6, 0x1c5, 0x092, 0x1f2, 0x13a, 0x1bc, 0x0e6, 0x100, 0x149, 0x0c6, 0x11d, 
	0x032, 0x074, 0x04e, 0x19a, 0x00a, 0x0cd, 0x1fe, 0x0ab, 0x0e7, 0x02d, 0x08b, 0x1d3, 0x01d, 0x056, 0x1f9, 0x020, 
	0x048, 0x01a, 0x156, 0x096, 0x139, 0x1ea, 0x1af, 0x0ee, 0x19b, 0x145, 0x095, 0x1d9, 0x028, 0x077, 0x0ae, 0x163, 
	0x0b9, 0x0e9, 0x185, 0x047, 0x1c0, 0x111, 0x174, 0x037, 0x06e, 0x0b2, 0x142, 0x00c, 0x1d5, 0x188, 0x171, 0x0be, 
	0x001, 0x06d, 0x177, 0x089, 0x0b5, 0x058, 0x04b, 0x134, 0x104, 0x1e4, 0x062, 0x110, 0x172, 0x113, 0x19c, 0x06f, 
	0x150, 0x13e, 0x004, 0x1f8, 0x1ec, 0x103, 0x130, 0x04d, 0x151, 0x1b3, 0x015, 0x165, 0x12f, 0x14c, 0x1e3, 0x012, 
	0x02f, 0x055, 0x019, 0x1f1, 0x1da, 0x121, 0x064, 0x10d, 0x128, 0x1de, 0x10e, 0x06a, 0x01f, 0x068, 0x1b1, 0x054, 
	0x19e, 0x1e6, 0x18a, 0x060, 0x063, 0x09a, 0x1ff, 0x094, 0x19d, 0x169, 0x199, 0x0ff, 0x0a2, 0x0d7, 0x12e, 0x0c9, 
	0x10a, 0x15f, 0x157, 0x090, 0x1b9, 0x16d, 0x06c, 0x12a, 0x0fb, 0x022, 0x0b6, 0x1fd, 0x08a, 0x0d2, 0x14f, 0x085, 
	0x137, 0x160, 0x148, 0x08d, 0x18c, 0x15a, 0x07b, 0x13f, 0x1c2, 0x119, 0x1ad, 0x0e4, 0x1bb, 0x1e1, 0x05c, 0x194, 
	0x1e5, 0x1a6, 0x0f8, 0x129, 0x017, 0x0d5, 0x082, 0x1d2, 0x016, 0x0d9, 0x11b, 0x046, 0x126, 0x168, 0x1a3, 0x07f, 
	0x138, 0x179, 0x007, 0x1d4, 0x0c2, 0x002, 0x075, 0x127, 0x1cf, 0x102, 0x0e0, 0x1bf, 0x0f7, 0x0bb, 0x050, 0x18e, 
	0x11c, 0x161, 0x069, 0x186, 0x12b, 0x1d7, 0x1d6, 0x0b8, 0x039, 0x0c8, 0x15c, 0x03f, 0x0cc, 0x0bc, 0x021, 0x1c3, 
	0x061, 0x01e, 0x136, 0x0db, 0x05e, 0x0a0, 0x081, 0x1ed, 0x040, 0x0b3, 0x107, 0x066, 0x0bd, 0x0cf, 0x072, 0x192, 
	0x1b6, 0x1dd, 0x183, 0x07a, 0x0c0, 0x02a, 0x17d, 0x005, 0x091, 0x076, 0x0b4, 0x1c1, 0x125, 0x143, 0x088, 0x17c, 
	0x02b, 0x042, 0x03c, 0x1c7, 0x155, 0x1bd, 0x0ca, 0x1b0, 0x008, 0x0ed, 0x00f, 0x178, 0x1b4, 0x1d0, 0x03b, 0x1cd
];

const KC = [0x0123,	0x4567,	0x89ab,	0xcdef,	0xfedc,	0xba98,	0x7654,	0x3210];

function FL(x, kl)
{
	const xl = x >>> 16;
	const xr = x & 0xffff;

	// KASUMI vs MISTY: Rotation added
	const yr = rol16(xl & kl[0], 1) ^ xr;
	const yl = rol16(yr | kl[1], 1) ^ xl;

	return (yl << 16) | yr;
}

// KASUMI vs MISTY: No need for inverse FL (due to "almost-Feistel")

function FI(x, k)
{
	let x9 = x >>> 7;
	let x7 = x & 0x7f;
	x9 = S_BOX_9[x9] ^ x7;
	x7 = (S_BOX_7[x7] ^ x9) & 0x7f;
	x7 ^= k >>> 9;
	x9 ^= k & 0x1ff;
	x9 = S_BOX_9[x9] ^ x7;
	// KASUMI vs MISTY: Additional step here, reflecting the last step for "x9":
	x7 = (S_BOX_7[x7] ^ x9) & 0x7f;
	return (x7 << 9) | x9;
}

function FO(x, ko, ki)
{
	let xl = x >>> 16;
	let xr = x & 0xffff;

	for (let j = 0; j < 3; j++)
	{
		const r = xr;
		xr = FI(xl ^ ko[j], ki[j]) ^ xr;
		xl = r;
	}

	// KASUMI vs MISTY1: No 4th KO key
	return (xl << 16) | xr;
}

class KasumiBaseTransform extends BlockCipherTransform
{
	constructor(decrypt)
	{
		super(decrypt);
		this.addOption("rounds", "Rounds", 8, { min: 4, step: 4 });
	}

	transform(bytes, keyBytes)
	{
		const rounds = this.options.rounds;

		this.checkBytesSize("Key", keyBytes, 128);

		const subKeys = this.generateSubKeys(keyBytes);
		const roundKeys = this.arrangeRoundKeys(subKeys, rounds);
		return this.transformBlocks(bytes, 64, roundKeys, rounds);
	}

	transformBlock(block, dest, destOffset, keys, rounds)
	{
		// KASUMI vs MISTY: *Almost* Feistel
		let [l, r] = bytesToInt32sBE(block);
		
		const KL = keys.kl,	KO = keys.ko, KI = keys.ki;
		let kl = 0,	ko = 0,	ki = 0;

		// Swap rounds for decrypt
		const odd = this.decrypt ? 1 : 0;

		// Likely due to how 3GPP only needed encryption, the "Feistel" network here isn't proper.
		// The left/right swap is included in the last round of encryption, so we need to "unswap"
		// it here to use *most* of the encryption structure for decryption.
		if (this.decrypt)
		{
			[l, r] = [r, l];
		}

		for (let i = 0; i < rounds; i++)
		{
			let temp;
			if (i % 2 === odd)
			{
				// Odd rounds (KASUMI counts from 1)
				temp = FL(l, KL[kl++]);
				temp = FO(temp, KO[ko++], KI[ki++]);
			}
			else
			{
				// Even rounds
				temp = FO(l, KO[ko++], KI[ki++]);
				temp = FL(temp, KL[kl++]);
			}

			r ^= temp;
			
			[l, r] = [r, l];
		}

		// See above - we need to "unswap" the last round
		if (this.decrypt)
		{
			[l, r] = [r, l];
		}

		dest.set(int32sToBytesBE([l, r]), destOffset);
	}

	arrangeRoundKeys(keys, rounds)
	{
		// MISTY's (and KASUMI's) key schedule includes three key types (KL, KI, KO), each of which is picked 
		// starting from its own offset in the user key or derived key set.
		// Since the memory savings (few bytes) aren't required here, we prepare the key types, duplicating
		// the key words and arranging them in a more logical object.
		// This makes the actual encryption function much more readable, and potentially increases actual
		// encryption performance with the same key, by replacing a lot of addition and modulo
		// operations during encryption with simple increments. It also makes decryption much simpler - see below.

		const { userKeys, derivedKeys } = keys;
		
		const ko = [];
		const kl = [];
		const ki = [];

		// KASUMI vs. MISTY: Different arrangement (and 1 less KO key per round)
		for (let i = 0; i < rounds; i++)
		{
			kl.push([
				rol16(userKeys[i % 8], 1), 
				derivedKeys[(i + 2) % 8]
			]);

			ko.push([
				rol16(userKeys[(i + 1) % 8], 5),
				rol16(userKeys[(i + 5) % 8], 8),
				rol16(userKeys[(i + 6) % 8], 13)
			]);

			ki.push([
				derivedKeys[(i + 4) % 8],
				derivedKeys[(i + 3) % 8],
				derivedKeys[(i + 7) % 8]
			]);
		}

		return { ko, kl, ki };
	}

	generateSubKeys(keyBytes)
	{
		const userKeys = bytesToInt16sBE(keyBytes);
		const derivedKeys = new Uint16Array(8);

		// Derive 8 additional key words through FI function
		// KASUMI vs. MISTY: Simple XORs with constant
		for (let i = 0; i < 8; i++)
		{
			derivedKeys[i] = userKeys[i] ^ KC[i];
		}

		return { userKeys, derivedKeys };
	}

}

class KasumiEncryptTransform extends KasumiBaseTransform
{
	constructor()
	{
		super(false);
	}
}

// Decryption simply uses an inverse FL function and reversed keys:
class KasumiDecryptTransform extends KasumiBaseTransform
{
	constructor()
	{
		super(true);
	}

	arrangeRoundKeys(subKeys, rounds)
	{
		const keys = super.arrangeRoundKeys(subKeys, rounds);
		keys.ko.reverse();
		keys.ki.reverse();
		keys.kl.reverse();
		return keys;
	}
}

export {
	KasumiEncryptTransform,
	KasumiDecryptTransform
};