import { BlockCipherTransform } from "./block-cipher";
import { TransformError } from "../transforms";
import { checkSize, hexToBytes, bytesToHex } from "../../cryptopunk.utils";

const ROUNDS = 32;

// Default S-box - as suggested by Yuval: The first 256 prime numbers modulo 256
const SBOX = [
	0x02, 0x03, 0x05, 0x07, 0x0b, 0x0d, 0x11, 0x13, 0x17, 0x1d, 0x1f, 0x25, 0x29, 0x2b, 0x2f, 0x35, 
	0x3b, 0x3d, 0x43, 0x47, 0x49, 0x4f, 0x53, 0x59, 0x61, 0x65, 0x67, 0x6b, 0x6d, 0x71, 0x7f, 0x83, 
	0x89, 0x8b, 0x95, 0x97, 0x9d, 0xa3, 0xa7, 0xad, 0xb3, 0xb5, 0xbf, 0xc1, 0xc5, 0xc7, 0xd3, 0xdf, 
	0xe3, 0xe5, 0xe9, 0xef, 0xf1, 0xfb, 0x01, 0x07, 0x0d, 0x0f, 0x15, 0x19, 0x1b, 0x25, 0x33, 0x37, 
	0x39, 0x3d, 0x4b, 0x51, 0x5b, 0x5d, 0x61, 0x67, 0x6f, 0x75, 0x7b, 0x7f, 0x85, 0x8d, 0x91, 0x99, 
	0xa3, 0xa5, 0xaf, 0xb1, 0xb7, 0xbb, 0xc1, 0xc9, 0xcd, 0xcf, 0xd3, 0xdf, 0xe7, 0xeb, 0xf3, 0xf7, 
	0xfd, 0x09, 0x0b, 0x1d, 0x23, 0x2d, 0x33, 0x39, 0x3b, 0x41, 0x4b, 0x51, 0x57, 0x59, 0x5f, 0x65, 
	0x69, 0x6b, 0x77, 0x81, 0x83, 0x87, 0x8d, 0x93, 0x95, 0xa1, 0xa5, 0xab, 0xb3, 0xbd, 0xc5, 0xcf, 
	0xd7, 0xdd, 0xe3, 0xe7, 0xef, 0xf5, 0xf9, 0x01, 0x05, 0x13, 0x1d, 0x29, 0x2b, 0x35, 0x37, 0x3b, 
	0x3d, 0x47, 0x55, 0x59, 0x5b, 0x5f, 0x6d, 0x71, 0x73, 0x77, 0x8b, 0x8f, 0x97, 0xa1, 0xa9, 0xad, 
	0xb3, 0xb9, 0xc7, 0xcb, 0xd1, 0xd7, 0xdf, 0xe5, 0xf1, 0xf5, 0xfb, 0xfd, 0x07, 0x09, 0x0f, 0x19, 
	0x1b, 0x25, 0x27, 0x2d, 0x3f, 0x43, 0x45, 0x49, 0x4f, 0x55, 0x5d, 0x63, 0x69, 0x7f, 0x81, 0x8b, 
	0x93, 0x9d, 0xa3, 0xa9, 0xb1, 0xbd, 0xc1, 0xc7, 0xcd, 0xcf, 0xd5, 0xe1, 0xeb, 0xfd, 0xff, 0x03, 
	0x09, 0x0b, 0x11, 0x15, 0x17, 0x1b, 0x27, 0x29, 0x2f, 0x51, 0x57, 0x5d, 0x65, 0x77, 0x81, 0x8f, 
	0x93, 0x95, 0x99, 0x9f, 0xa7, 0xab, 0xad, 0xb3, 0xbf, 0xc9, 0xcb, 0xcf, 0xd1, 0xd5, 0xdb, 0xe7, 
	0xf3, 0xfb, 0x07, 0x0d, 0x11, 0x17, 0x1f, 0x23, 0x2b, 0x2f, 0x3d, 0x41, 0x47, 0x49, 0x4d, 0x53
];

class TreyferTransform extends BlockCipherTransform
{
	constructor(decrypt)
	{
		super(decrypt);
		this.addInput("bytes", "S-box");
	}

	transform(bytes, keyBytes, sboxBytes)
	{
		this.checkKeySize(keyBytes, 64);

		if (sboxBytes && sboxBytes.length > 0)
		{
			const requirement = checkSize(sboxBytes.length, 256);
			if (requirement)
			{
				throw new TransformError(`S-box must be ${requirement} bytes. Was: ${sboxBytes.length} bytes.`);
			}
		}
		else
		{
			sboxBytes = SBOX;
		}

		return this.transformBlocks(bytes, 64, keyBytes, sboxBytes);
	}
}

class TreyferEncryptTransform extends TreyferTransform
{
	constructor()
	{
		super(false);
	}

	transformBlock(block, dest, destOffset, keyBytes, sbox)
	{
		const x = Uint8Array.from(block);

		for (let r = 0; r < ROUNDS; r++)
		{
			for (let i = 0; i < 8; i++)
			{
				const i1 = (i + 1) % 8;
				let t = x[i1];
				t = (t + sbox[(keyBytes[i] + x[i]) & 0xff]) & 0xff;
				t = (t << 1 | t >>> 7);
				x[i1] = t;
			}
		}
		dest.set(x, destOffset);
	}
}

class TreyferDecryptTransform extends TreyferTransform
{
	constructor()
	{
		super(true);
	}

	transformBlock(block, dest, destOffset, keyBytes, sbox)
	{
		const x = Uint8Array.from(block);

		for (let r = 0; r < ROUNDS; r++)
		{
			for (let i = 7; i >= 0; i--)
			{
				const i1 = (i + 1) % 8;
				let t = x[i1];
				t = (t << 7 | t >>> 1) & 0xff;
				t = (t - sbox[(keyBytes[i] + x[i]) & 0xff]);
				x[i1] = t;
			}
		}
		dest.set(x, destOffset);
	}
}

export {
	TreyferEncryptTransform,
	TreyferDecryptTransform
};